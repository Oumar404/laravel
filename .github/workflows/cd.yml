name: CD

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'k8s/**'
      - 'monitoring/**'

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.29.0'

      - name: Set KUBECONFIG
        shell: bash
        run: |
          set -euo pipefail

          echo "================================================"
          echo "DIAGNOSTIC KUBECONFIG"
          echo "================================================"

          echo "[info] Secret length RAW: ${#KUBE_CONFIG} characters"
          echo "[info] First 80 chars: ${KUBE_CONFIG:0:80}"
          echo "[info] Last 40 chars: ${KUBE_CONFIG: -40}"

          # Installer outils de validation
          echo "[info] Installing validation tools..."
          sudo apt-get update -qq >/dev/null 2>&1
          sudo apt-get install -y -qq jq openssl >/dev/null 2>&1
          
          # Installer yq v4 pour parser YAML de manière robuste
          if ! command -v yq >/dev/null 2>&1; then
            echo "[info] Installing yq..."
            sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
            sudo chmod +x /usr/local/bin/yq
          fi

          # Détecter si KUBE_CONFIG est base64 ou YAML brut
          CLEAN="${KUBE_CONFIG//[$'\r\n']}"  # retire CR/LF pour test
          if [[ "${CLEAN}" =~ ^[A-Za-z0-9+/]+={0,2}$ ]]; then
            echo "[info] Secret looks like base64 -> decoding"
            if ! echo "${CLEAN}" | base64 -d > kubeconfig 2>/tmp/base64.err; then
              echo "[ERROR] Failed to decode base64:"
              sed -n '1,200p' /tmp/base64.err || true
              exit 1
            fi
          else
            echo "[info] Secret does NOT look like base64 -> assuming raw kubeconfig YAML"
            # Écrire tel quel (GitHub secrets préservent les newlines)
            printf "%s\n" "${KUBE_CONFIG}" > kubeconfig
          fi

          echo "[info] Decoded file size: $(wc -c < kubeconfig) bytes"
          echo "[info] Preview (first 30 lines):"
          sed -n '1,30p' kubeconfig || true

          # Vérifier que c'est du YAML valide avec apiVersion
          if ! yq e '.apiVersion' kubeconfig >/dev/null 2>&1; then
            echo "[ERROR] kubeconfig does not appear to be valid YAML or missing apiVersion"
            exit 1
          fi
          API=$(yq e '.apiVersion' kubeconfig)
          echo "[info] ✅ apiVersion: ${API}"

          # Extraire certificates via yq (plus robuste que grep/awk)
          CA_B64=$(yq e '.clusters[0].cluster."certificate-authority-data" // ""' -r kubeconfig)
          CLIENT_CERT_B64=$(yq e '.users[0].user."client-certificate-data" // ""' -r kubeconfig)
          CLIENT_KEY_B64=$(yq e '.users[0].user."client-key-data" // ""' -r kubeconfig)

          MISSING=""
          if [ -z "$CA_B64" ]; then MISSING="${MISSING}\n - certificate-authority-data"; fi
          if [ -z "$CLIENT_CERT_B64" ]; then MISSING="${MISSING}\n - client-certificate-data"; fi
          if [ -z "$CLIENT_KEY_B64" ]; then MISSING="${MISSING}\n - client-key-data"; fi
          if [ -n "$MISSING" ]; then
            echo "[ERROR] Missing required certificate fields:${MISSING}"
            echo "[info] If using token-based auth, adapt validation accordingly"
            exit 1
          fi

          echo "[info] ✅ All certificate fields present"
          echo "[info] Validating certificate PEM contents via openssl..."

          # Valider certificate-authority-data avec openssl
          echo "$CA_B64" | base64 -d > ca.pem 2>/tmp/ca.err || { 
            echo "[ERROR] Decoding CA failed"; 
            sed -n '1,100p' /tmp/ca.err; 
            exit 1; 
          }
          if ! openssl x509 -in ca.pem -noout -subject >/dev/null 2>&1; then
            echo "[ERROR] certificate-authority-data is not a valid PEM certificate"
            echo "[info] ca.pem preview:"
            sed -n '1,5p' ca.pem || true
            exit 1
          fi
          echo "[info] ✅ certificate-authority-data PEM valid"

          # Valider client-certificate-data
          echo "$CLIENT_CERT_B64" | base64 -d > client.crt 2>/tmp/cc.err || { 
            echo "[ERROR] Decoding client cert failed"; 
            sed -n '1,80p' /tmp/cc.err; 
            exit 1; 
          }
          if ! openssl x509 -in client.crt -noout -subject >/dev/null 2>&1; then
            echo "[ERROR] client-certificate-data is not a valid PEM certificate"
            sed -n '1,8p' client.crt || true
            exit 1
          fi
          echo "[info] ✅ client-certificate-data PEM valid"

          # Valider client-key-data
          echo "$CLIENT_KEY_B64" | base64 -d > client.key 2>/tmp/ck.err || { 
            echo "[ERROR] Decoding client key failed"; 
            sed -n '1,80p' /tmp/ck.err; 
            exit 1; 
          }
          if ! openssl pkey -in client.key -noout -pubout >/dev/null 2>&1; then
            # Fallback pour clés RSA anciennes
            if ! openssl rsa -in client.key -check -noout >/dev/null 2>&1; then
              echo "[ERROR] client-key-data is not a valid PEM private key"
              sed -n '1,8p' client.key || true
              exit 1
            fi
          fi
          echo "[info] ✅ client-key-data PEM valid"

          echo "================================================"
          echo "[info] ✅✅✅ Kubeconfig fully validated!"
          echo "================================================"

          # Afficher configuration minifiée (kubectl masquera les secrets)
          kubectl config view --kubeconfig=kubeconfig --minify || true

          # Protéger le fichier
          chmod 600 kubeconfig
        env:
          KUBE_CONFIG: ${{ secrets.KUBE_CONFIG }}

      - name: kubectl apply
        env:
          KUBECONFIG: ${{ github.workspace }}/kubeconfig
        run: |
          kubectl version --client=true
          kubectl apply -f k8s/namespace.yaml
          kubectl apply -f k8s/ -n gestion-notes
          kubectl apply -f monitoring/ -n gestion-notes || true
